This repo is my Docker learning playground.
I used simple Streamlit + Flask apps just for learning Docker concepts â€” not real production apps.
The goal is:
â€¢ understand Docker basics
â€¢ networking
â€¢ volumes
â€¢ docker-compose
â€¢ common errors (and why they happen)
â¸»
ğŸ§  What is Docker (simple)
Docker is use and throw tech ğŸ˜„
You define everything once (image, network, volume), Docker handles:
â€¢ namespaces
â€¢ cgroups
â€¢ isolation
â€¢ networking
Same Linux kernel, different containers â†’ lightweight, no VM drama.
â¸»
ğŸ§± Core Docker Components (important)
1ï¸âƒ£ Image
â€¢ Blueprint
â€¢ Created using Dockerfile
â€¢ Immutable
docker build -t my-image .

â¸»
2ï¸âƒ£ Container
â€¢ Running instance of image
â€¢ Temporary by default (dies â†’ data gone)
docker run -d -p 8501:8501 my-image

â¸»
3ï¸âƒ£ Dockerfile (what I learned)
Dockerfile is layer based.
Each instruction = new layer.
Important rules:
â€¢ FROM must come first
â€¢ Order matters for caching
â€¢ Small base image = smaller final image
Example:
FROM python:3.11-slim
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python","-m","streamlit","run","app.py"]

â¸»
ğŸ—ï¸ Multi-stage Build (where I struggled ğŸ˜­)
Why multi-stage?
â€¢ builder image â†’ install heavy stuff
â€¢ runtime image â†’ only what is needed
Key concept:
Runtime dependencies must exist in final image
Mistake I made:
â€¢ Installed Streamlit in builder
â€¢ Copied only app files
â€¢ Final image didnâ€™t have streamlit binary â†’ crash
Correct pattern (Streamlit case):
FROM python:3.11-slim AS builder
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
FROM python:3.11-slim
WORKDIR /app
COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder /app /app
CMD ["python","-m","streamlit","run","streamlit_app.py"]

â¸»
ğŸŒ Docker Networking (no NAT headache ğŸ˜Œ)
Bridge network (default & most used)
â€¢ Containers get private IP
â€¢ Docker provides built-in DNS
â€¢ Service name = hostname
Example:
services:
 backend:
   networks:
     - back-net
 frontend:
   networks:
     - front-net
Inside frontend:
curl http://backend:5000
No IP needed, Docker resolves it.
â¸»
Important rule
âŒ localhost inside container â‰  host
âœ” service-name:port works
â¸»
ğŸ“¦ Docker Volumes (this was confusing initially)
Truth bomb ğŸ’£
Container filesystem is temporary
If container dies â†’ data gone.
â¸»
Volume = persistent storage
Example:
volumes:
 word-data:
services:
 backend:
   volumes:
     - word-data:/data
This does:
â€¢ Creates volume
â€¢ Mounts it to /data
â€¢ Data survives container restart
â¸»
Where data actually lives
On host:
/var/lib/docker/volumes/word-data/_data/

â¸»
My mistake
â€¢ App wrote to /data/words.txt
â€¢ Volume was NOT mounted
â€¢ /data didnâ€™t exist â†’ confusion
Fix:
â€¢ Mount volume
â€¢ Or create directory explicitly
os.makedirs("/data", exist_ok=True)

â¸»
ğŸ§© docker-compose (life saver)
docker-compose is:
â€œRun multiple containers without losing sanityâ€
docker compose up
docker compose down
â€¢ up â†’ creates containers
â€¢ down â†’ deletes containers (volumes stay unless -v)
Scaling issue:
â€¢ container_name blocks scaling
â€¢ Remove it if you want multiple replicas
â¸»
ğŸ”¥ Common Errors I Faced (and WHY)
âŒ Port already allocated
Bind for 0.0.0.0:8501 failed
Reason:
â€¢ Another container already using same port
Fix:
docker ps
docker stop <container>

â¸»
âŒ streamlit: executable not found in $PATH
Reason:
â€¢ Streamlit not installed in final image
Fix:
â€¢ Install in runtime stage
â€¢ Or use python -m streamlit
â¸»
âŒ No space left in container
Reason:
â€¢ Small base image
â€¢ Docker disk full
Fix:
docker system prune -a

â¸»
âŒ Authentication failed (GitHub)
Reason:
â€¢ GitHub doesnâ€™t accept passwords anymore
Fix:
â€¢ Use Personal Access Token
â€¢ Or SSH keys
â¸»
ğŸ§  Git + Docker (important concept)
Thing Goes where
Source code Git
Docker images Docker registry
Data Volumes
Secrets env / secret manager
Artifacts S3 / Nexus

â¸»
âŒ What NOT to commit to Git
Never commit:
â€¢ .tar.gz
â€¢ node_modules
â€¢ venv
â€¢ Docker images
â€¢ .env
Use .gitignore.
â¸»
ğŸ§ª Why Streamlit / Flask apps exist here
They are just demo apps:
â€¢ frontend â†’ UI
â€¢ backend â†’ API
â€¢ DB â†’ postgres
Purpose:
â€¢ test networking
â€¢ test volumes
â€¢ test compose
â¸»
ğŸ§  Final Mental Model
Docker is:
â€¢ declarative
â€¢ disposable
â€¢ predictable
If something breaks:
â€¢ delete container
â€¢ rebuild image
â€¢ re-run
No emotional attachment ğŸ˜„
â¸»
ğŸ Next Topics to Revise Later
â€¢ Docker image optimization
â€¢ Docker security basics
â€¢ Docker + CI/CD
â€¢ Kubernetes (after Docker mastery)
â¸»
End of notes.
If future-me is reading this â€” you struggled, but you got it ğŸ’ª
â¸»
If you want, next I can:
â€¢ convert this into interview Q&A
â€¢ compress it into one-page cheatsheet
â€¢ or add Kubernetes mapping to this Docker knowledge
Just say ğŸ‘Perfect idea ğŸ‘
This is exactly how a good README should be â€” future-you friendly, not textbook garbage.
Below is a ready-to-paste README.md written in your style (the way you talk to me ğŸ˜„).
You can copy this as-is and tweak later.
â¸»
ğŸ³ Docker Practice Notes (My Language, No Bakwas)
This repo is my Docker learning playground.
I used simple Streamlit + Flask apps just for learning Docker concepts â€” not real production apps.
The goal is:
â€¢ understand Docker basics
â€¢ networking
â€¢ volumes
â€¢ docker-compose
â€¢ common errors (and why they happen)
â¸»
ğŸ§  What is Docker (simple)
Docker is use and throw tech ğŸ˜„
You define everything once (image, network, volume), Docker handles:
â€¢ namespaces
â€¢ cgroups
â€¢ isolation
â€¢ networking
Same Linux kernel, different containers â†’ lightweight, no VM drama.
â¸»
ğŸ§± Core Docker Components (important)
1ï¸âƒ£ Image
â€¢ Blueprint
â€¢ Created using Dockerfile
â€¢ Immutable
docker build -t my-image .

â¸»
2ï¸âƒ£ Container
â€¢ Running instance of image
â€¢ Temporary by default (dies â†’ data gone)
docker run -d -p 8501:8501 my-image

â¸»
3ï¸âƒ£ Dockerfile (what I learned)
Dockerfile is layer based.
Each instruction = new layer.
Important rules:
â€¢ FROM must come first
â€¢ Order matters for caching
â€¢ Small base image = smaller final image
Example:
FROM python:3.11-slim
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python","-m","streamlit","run","app.py"]

â¸»
ğŸ—ï¸ Multi-stage Build (where I struggled ğŸ˜­)
Why multi-stage?
â€¢ builder image â†’ install heavy stuff
â€¢ runtime image â†’ only what is needed
Key concept:
Runtime dependencies must exist in final image
Mistake I made:
â€¢ Installed Streamlit in builder
â€¢ Copied only app files
â€¢ Final image didnâ€™t have streamlit binary â†’ crash
Correct pattern (Streamlit case):
FROM python:3.11-slim AS builder
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
FROM python:3.11-slim
WORKDIR /app
COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder /app /app
CMD ["python","-m","streamlit","run","streamlit_app.py"]

â¸»
ğŸŒ Docker Networking (no NAT headache ğŸ˜Œ)
Bridge network (default & most used)
â€¢ Containers get private IP
â€¢ Docker provides built-in DNS
â€¢ Service name = hostname
Example:
services:
 backend:
   networks:
     - back-net
 frontend:
   networks:
     - front-net
Inside frontend:
curl http://backend:5000
No IP needed, Docker resolves it.
â¸»
Important rule
âŒ localhost inside container â‰  host
âœ” service-name:port works
â¸»
ğŸ“¦ Docker Volumes (this was confusing initially)
Truth bomb ğŸ’£
Container filesystem is temporary
If container dies â†’ data gone.
â¸»
Volume = persistent storage
Example:
volumes:
 word-data:
services:
 backend:
   volumes:
     - word-data:/data
This does:
â€¢ Creates volume
â€¢ Mounts it to /data
â€¢ Data survives container restart
â¸»
Where data actually lives
On host:
/var/lib/docker/volumes/word-data/_data/

â¸»
My mistake
â€¢ App wrote to /data/words.txt
â€¢ Volume was NOT mounted
â€¢ /data didnâ€™t exist â†’ confusion
Fix:
â€¢ Mount volume
â€¢ Or create directory explicitly
os.makedirs("/data", exist_ok=True)

â¸»
ğŸ§© docker-compose (life saver)
docker-compose is:
â€œRun multiple containers without losing sanityâ€
docker compose up
docker compose down
â€¢ up â†’ creates containers
â€¢ down â†’ deletes containers (volumes stay unless -v)
Scaling issue:
â€¢ container_name blocks scaling
â€¢ Remove it if you want multiple replicas
â¸»
ğŸ”¥ Common Errors I Faced (and WHY)
âŒ Port already allocated
Bind for 0.0.0.0:8501 failed
Reason:
â€¢ Another container already using same port
Fix:
docker ps
docker stop <container>

â¸»
âŒ streamlit: executable not found in $PATH
Reason:
â€¢ Streamlit not installed in final image
Fix:
â€¢ Install in runtime stage
â€¢ Or use python -m streamlit
â¸»
âŒ No space left in container
Reason:
â€¢ Small base image
â€¢ Docker disk full
Fix:
docker system prune -a

â¸»
âŒ Authentication failed (GitHub)
Reason:
â€¢ GitHub doesnâ€™t accept passwords anymore
Fix:
â€¢ Use Personal Access Token
â€¢ Or SSH keys
â¸»
ğŸ§  Git + Docker (important concept)
Thing Goes where
Source code Git
Docker images Docker registry
Data Volumes
Secrets env / secret manager
Artifacts S3 / Nexus

â¸»
âŒ What NOT to commit to Git
Never commit:
â€¢ .tar.gz
â€¢ node_modules
â€¢ venv
â€¢ Docker images
â€¢ .env
Use .gitignore.
â¸»
ğŸ§ª Why Streamlit / Flask apps exist here
They are just demo apps:
â€¢ frontend â†’ UI
â€¢ backend â†’ API
â€¢ DB â†’ postgres
Purpose:
â€¢ test networking
â€¢ test volumes
â€¢ test compose
â¸»
ğŸ§  Final Mental Model
Docker is:
â€¢ declarative
â€¢ disposable
â€¢ predictable
If something breaks:
â€¢ delete container
â€¢ rebuild image
â€¢ re-run
No emotional attachment ğŸ˜„

This repo is my Docker learning playground.
I used simple Streamlit + Flask apps just for learning Docker concepts â€” not real production apps.
The goal is:
â€¢ understand Docker basics
â€¢ networking
â€¢ volumes
â€¢ docker-compose
â€¢ common errors (and why they happen)
â¸»
ğŸ§  What is Docker (simple)
Docker is use and throw tech ğŸ˜„
You define everything once (image, network, volume), Docker handles:
â€¢ namespaces
â€¢ cgroups
â€¢ isolation
â€¢ networking
Same Linux kernel, different containers â†’ lightweight, no VM drama.
â¸»
ğŸ§± Core Docker Components (important)
1ï¸âƒ£ Image
â€¢ Blueprint
â€¢ Created using Dockerfile
â€¢ Immutable
docker build -t my-image .

â¸»
2ï¸âƒ£ Container
â€¢ Running instance of image
â€¢ Temporary by default (dies â†’ data gone)
docker run -d -p 8501:8501 my-image

â¸»
3ï¸âƒ£ Dockerfile (what I learned)
Dockerfile is layer based.
Each instruction = new layer.
Important rules:
â€¢ FROM must come first
â€¢ Order matters for caching
â€¢ Small base image = smaller final image
Example:
FROM python:3.11-slim
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python","-m","streamlit","run","app.py"]

â¸»
ğŸ—ï¸ Multi-stage Build (where I struggled ğŸ˜­)
Why multi-stage?
â€¢ builder image â†’ install heavy stuff
â€¢ runtime image â†’ only what is needed
Key concept:
Runtime dependencies must exist in final image
Mistake I made:
â€¢ Installed Streamlit in builder
â€¢ Copied only app files
â€¢ Final image didnâ€™t have streamlit binary â†’ crash
Correct pattern (Streamlit case):
FROM python:3.11-slim AS builder
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
FROM python:3.11-slim
WORKDIR /app
COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder /app /app
CMD ["python","-m","streamlit","run","streamlit_app.py"]

â¸»
ğŸŒ Docker Networking (no NAT headache ğŸ˜Œ)
Bridge network (default & most used)
â€¢ Containers get private IP
â€¢ Docker provides built-in DNS
â€¢ Service name = hostname
Example:
services:
 backend:
   networks:
     - back-net
 frontend:
   networks:
     - front-net
Inside frontend:
curl http://backend:5000
No IP needed, Docker resolves it.
â¸»
Important rule
âŒ localhost inside container â‰  host
âœ” service-name:port works
â¸»
ğŸ“¦ Docker Volumes (this was confusing initially)
Truth bomb ğŸ’£
Container filesystem is temporary
If container dies â†’ data gone.
â¸»
Volume = persistent storage
Example:
volumes:
 word-data:
services:
 backend:
   volumes:
     - word-data:/data
This does:
â€¢ Creates volume
â€¢ Mounts it to /data
â€¢ Data survives container restart
â¸»
Where data actually lives
On host:
/var/lib/docker/volumes/word-data/_data/

â¸»
My mistake
â€¢ App wrote to /data/words.txt
â€¢ Volume was NOT mounted
â€¢ /data didnâ€™t exist â†’ confusion
Fix:
â€¢ Mount volume
â€¢ Or create directory explicitly
os.makedirs("/data", exist_ok=True)

â¸»
ğŸ§© docker-compose (life saver)
docker-compose is:
â€œRun multiple containers without losing sanityâ€
docker compose up
docker compose down
â€¢ up â†’ creates containers
â€¢ down â†’ deletes containers (volumes stay unless -v)
Scaling issue:
â€¢ container_name blocks scaling
â€¢ Remove it if you want multiple replicas
â¸»
ğŸ”¥ Common Errors I Faced (and WHY)
âŒ Port already allocated
Bind for 0.0.0.0:8501 failed
Reason:
â€¢ Another container already using same port
Fix:
docker ps
docker stop <container>

â¸»
âŒ streamlit: executable not found in $PATH
Reason:
â€¢ Streamlit not installed in final image
Fix:
â€¢ Install in runtime stage
â€¢ Or use python -m streamlit
â¸»
âŒ No space left in container
Reason:
â€¢ Small base image
â€¢ Docker disk full
Fix:
docker system prune -a

â¸»
âŒ Authentication failed (GitHub)
Reason:
â€¢ GitHub doesnâ€™t accept passwords anymore
Fix:
â€¢ Use Personal Access Token
â€¢ Or SSH keys
â¸»
ğŸ§  Git + Docker (important concept)
Thing Goes where
Source code Git
Docker images Docker registry
Data Volumes
Secrets env / secret manager
Artifacts S3 / Nexus

â¸»
âŒ What NOT to commit to Git
Never commit:
â€¢ .tar.gz
â€¢ node_modules
â€¢ venv
â€¢ Docker images
â€¢ .env
Use .gitignore.
â¸»
ğŸ§ª Why Streamlit / Flask apps exist here
They are just demo apps:
â€¢ frontend â†’ UI
â€¢ backend â†’ API
â€¢ DB â†’ postgres
Purpose:
â€¢ test networking
â€¢ test volumes
â€¢ test compose
â¸»
ğŸ§  Final Mental Model
Docker is:
â€¢ declarative
â€¢ disposable
â€¢ predictable
If something breaks:
â€¢ delete container
â€¢ rebuild image
â€¢ re-run
No emotional attachment ğŸ˜„
#trigger action
second trial

ci/cd-k8s PART--------------------------------------
ğŸ˜‚ğŸ˜‚ OK OK I GOT YOU.
You donâ€™t want â€œpolished portfolio READMEâ€.
You want **YOUR NOTES**, in **YOUR STYLE**, for **INTERVIEW REVISION**.

Like:

> â€œOpen README â†’ revise â†’ brain refresh â†’ go interview.â€

Letâ€™s continue from where you stopped, same tone, same vibe.

You can paste this **after your last line**.

---

## â¸»

## âš™ï¸ CI/CD (GitHub Actions â€“ My Learning)

CI/CD =
â€œAutomatically build, test, and deploy when I push codeâ€

Flow I used:

Git push
â†’ GitHub Actions runs
â†’ Build Docker images
â†’ Push to DockerHub
â†’ (Later) Deploy to VM / K8s

So I donâ€™t manually do:

docker build
docker push
docker pull
docker run

Every time ğŸ˜Œ

### ğŸ“ Where CI Lives

Inside repo:
.github/workflows/main.yml
If file is not here â†’ Action wonâ€™t run âŒ

My mistake:

â€¢ Put workflow in wrong folder
â€¢ Nothing triggered
â€¢ Confused ğŸ˜­

Fix:
Put inside `.github/workflows/`

---

### ğŸ—ï¸ Basic CI Steps

My pipeline:

1ï¸âƒ£ Checkout code
2ï¸âƒ£ Login to DockerHub
3ï¸âƒ£ Build images
4ï¸âƒ£ Push images

Example logic:

uses: actions/checkout
docker login
docker compose build
docker compose push

---

### ğŸ” Secrets (Important)

Never hardcode password in YAML âŒ

Use:
GitHub Repo â†’ Settings â†’ Secrets

Example:
DKRHUB_UNAME
DKRHUB_PSWD
VM_SSH_KEY

Then in YAML:
${{ secrets.NAME }}
---

### âŒ CI Error: Docker Login Failed

Reason:
â€¢ Used normal password
â€¢ DockerHub now needs token

Fix:
â€¢ Create access token
â€¢ Use token as password

---

### âŒ CI Didnâ€™t Trigger

Reason:
â€¢ Wrong branch name
â€¢ Wrong folder
â€¢ Wrong YAML syntax

Fix:
Check:
on:
  push:
    branches:
      - main
---

### ğŸ·ï¸ Image Tagging (Important Concept)

Instead of:
latest

I used:
github.sha

So every build = unique tag.

Example:
frontend:fbb04518...
Benefit:

âœ” Rollback
âœ” Traceable
âœ” No overwrite

---

## â¸»

## ğŸš€ CD (Deployment Part â€“ What I Learned)

CD =
â€œAfter build, automatically deployâ€

I used:

â€¢ SSH into VM
â€¢ Pull new image
â€¢ Run compose

Flow:

GitHub â†’ SSH â†’ VM â†’ docker compose up

Using:
appleboy/ssh-action
---

### âŒ SSH Failed

Error:

handshake failed
Reason:
â€¢ No authorized_keys
â€¢ Wrong key
â€¢ Permission issue

Fix:
~/.ssh/authorized_keys
chmod 600
---

### âŒ IP Changed

Cloud VM IP changes sometimes.

Fix:
â€¢ Use static IP
â€¢ Or update secrets

---

## â¸»

## â˜¸ï¸ Kubernetes (Real Learning Started Here ğŸ˜­ğŸ”¥)

Kubernetes =
â€œDocker + automation + scaling + healingâ€

Docker = single machine
K8s = multi machine

---

### ğŸ§± Core K8s Components

#### 1ï¸âƒ£ Pod

Smallest unit.

Contains container(s).

Temporary.

Dies â†’ recreated.

---

#### 2ï¸âƒ£ Deployment

Manages pods.

Handles:

â€¢ Scaling
â€¢ Restart
â€¢ Rollout

Example:
bash
kubectl apply -f deploy.yaml
---

#### 3ï¸âƒ£ Service

Exposes pods.

Gives stable DNS.

Important:

Pod IP changes âŒ
Service IP stable âœ…

---

Types:

ClusterIP â†’ internal
NodePort â†’ external
LoadBalancer â†’ cloud

---

#### 4ï¸âƒ£ Namespace

Logical separation.

Default = default.

---

## â¸»

## ğŸŒ K8s Networking (Important)

Rule:

Pod â†’ Pod = direct
Service â†’ Pod = via DNS

DNS format:
service-name
Example:
http://backend:5000
---

### âŒ My Mistake

Used:

```
localhost
```

Inside container âŒ

Fix:

Use service name.

---

## â¸»
## ğŸ” K8s Secrets (Painful Part ğŸ˜­)
Used for:
â€¢ DB password
â€¢ Docker registry auth

Example:
imagePullSecrets
---

### âŒ ImagePullBackOff

Reason:

â€¢ Private image
â€¢ No auth

Fix:
Create secret:
kubectl create secret docker-registry
---
### âŒ Wrong Secret
Used wrong password.
Fix:
Use DockerHub token.
---
## â¸»

## ğŸ’¾ K8s + Database (Postgres)

DB is another pod.

Need:

â€¢ Deployment
â€¢ Service
â€¢ Env vars

---

### âŒ DB Not Ready

Error:
connection failed
Reason:
â€¢ DB not started
â€¢ Wrong host
â€¢ Wrong password

Fix:

Check:
kubectl logs
kubectl exec -- env

---

### âŒ No Password Supplied

Reason:
Env var missing.

Fix:
Fix deployment YAML.

---

## â¸»

## ğŸ K8s Debugging Cheat Sheet

When stuck:

### Pods
kubectl get pods
### Details
kubectl describe pod
### Logs
kubectl logs
### Inside pod
kubectl exec -it -- sh
### Services
kubectl get svc
---

## â¸»

## âš¡ Resource Management

Limit CPU/RAM:

yaml
resources:
  limits:
    memory: "512Mi"
    cpu: "500m"

Prevents one pod from killing others.
---
## â¸»

## ğŸ“ˆ Scaling

Manual:
kubectl scale deployment backend --replicas=3
Auto (HPA):

CPU based scaling.

---

## â¸»

## ğŸ§  Interview Mental Map

When asked â€œHow do you deploy?â€

Answer:
Code â†’ GitHub
CI â†’ Build image
Registry â†’ Store image
CD â†’ Deploy
K8s â†’ Run + Scale

---
When asked â€œHow debug?â€
Answer:
get â†’ describe â†’ logs â†’ exec
